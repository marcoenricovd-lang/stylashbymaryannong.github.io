{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Marco/OneDrive/Desktop/test/stylash/lib/auth.ts"],"sourcesContent":["import bcrypt from 'bcryptjs';\r\nimport { AdminSession, LoginAttempt, AdminAction } from './types';\r\n\r\n// Hardcoded admin password hash (bcrypt with salt rounds 12)\r\n// Password: 7H39E8V8U4PK\r\nconst ADMIN_PASSWORD_HASH = '$2b$12$FclzLgK0BbJ1TDa6S.vaGeWli5bagjk8u3GCMy/ish1Rux8PRCDGa';\r\n\r\n// Session timeout: 30 minutes in milliseconds\r\nconst SESSION_TIMEOUT = 30 * 60 * 1000;\r\n\r\n// Lockout settings\r\nconst MAX_FAILED_ATTEMPTS = 5;\r\nconst LOCKOUT_DURATION = 30 * 60 * 1000; // 30 minutes\r\n\r\n// Storage keys\r\nconst SESSION_KEY = 'stylash_admin_session';\r\nconst LOGIN_ATTEMPTS_KEY = 'stylash_login_attempts';\r\nconst ADMIN_ACTIONS_KEY = 'stylash_admin_actions';\r\n\r\n// Get client IP address (simulated - in production, get from request headers)\r\nfunction getClientIp(): string {\r\n  if (typeof window === 'undefined') return 'unknown';\r\n  // In a real production environment, this would come from the server\r\n  // For client-side, we'll use a stored value or generate a fingerprint\r\n  let ip = localStorage.getItem('stylash_client_ip');\r\n  if (!ip) {\r\n    // Generate a simple fingerprint for this browser session\r\n    ip = `client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n    localStorage.setItem('stylash_client_ip', ip);\r\n  }\r\n  return ip;\r\n}\r\n\r\n// Generate session token\r\nfunction generateSessionToken(): string {\r\n  return `session-${Date.now()}-${Math.random().toString(36).substr(2, 16)}`;\r\n}\r\n\r\n// Check if account is locked\r\nexport function isAccountLocked(): boolean {\r\n  if (typeof window === 'undefined') return false;\r\n  \r\n  const attempts = getLoginAttempts();\r\n  const ip = getClientIp();\r\n  const recentAttempts = attempts.filter(\r\n    a => a.ipAddress === ip && !a.successful\r\n  );\r\n  \r\n  // Count failures in the last lockout window\r\n  const cutoffTime = Date.now() - LOCKOUT_DURATION;\r\n  const recentFailures = recentAttempts.filter(\r\n    a => new Date(a.timestamp).getTime() > cutoffTime\r\n  );\r\n  \r\n  if (recentFailures.length >= MAX_FAILED_ATTEMPTS) {\r\n    const lastFailure = recentFailures[recentFailures.length - 1];\r\n    const lockedUntil = new Date(lastFailure.timestamp).getTime() + LOCKOUT_DURATION;\r\n    return Date.now() < lockedUntil;\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\n// Get remaining lockout time in minutes\r\nexport function getLockoutTimeRemaining(): number {\r\n  if (typeof window === 'undefined') return 0;\r\n  \r\n  const attempts = getLoginAttempts();\r\n  const ip = getClientIp();\r\n  const recentAttempts = attempts.filter(\r\n    a => a.ipAddress === ip && !a.successful\r\n  );\r\n  \r\n  const cutoffTime = Date.now() - LOCKOUT_DURATION;\r\n  const recentFailures = recentAttempts.filter(\r\n    a => new Date(a.timestamp).getTime() > cutoffTime\r\n  );\r\n  \r\n  if (recentFailures.length >= MAX_FAILED_ATTEMPTS) {\r\n    const lastFailure = recentFailures[recentFailures.length - 1];\r\n    const lockedUntil = new Date(lastFailure.timestamp).getTime() + LOCKOUT_DURATION;\r\n    const remaining = lockedUntil - Date.now();\r\n    return Math.ceil(remaining / 60000); // Convert to minutes\r\n  }\r\n  \r\n  return 0;\r\n}\r\n\r\n// Get login attempts from storage\r\nfunction getLoginAttempts(): LoginAttempt[] {\r\n  if (typeof window === 'undefined') return [];\r\n  const stored = localStorage.getItem(LOGIN_ATTEMPTS_KEY);\r\n  return stored ? JSON.parse(stored) : [];\r\n}\r\n\r\n// Save login attempt\r\nfunction saveLoginAttempt(successful: boolean): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  const attempts = getLoginAttempts();\r\n  const ip = getClientIp();\r\n  \r\n  // Count recent failures for this IP\r\n  const cutoffTime = Date.now() - LOCKOUT_DURATION;\r\n  const recentFailures = attempts.filter(\r\n    a => a.ipAddress === ip && !a.successful && new Date(a.timestamp).getTime() > cutoffTime\r\n  );\r\n  \r\n  const newAttempt: LoginAttempt = {\r\n    id: `attempt-${Date.now()}`,\r\n    ipAddress: ip,\r\n    timestamp: new Date().toISOString(),\r\n    successful,\r\n    failureCount: successful ? 0 : recentFailures.length + 1,\r\n  };\r\n  \r\n  attempts.push(newAttempt);\r\n  \r\n  // Keep only last 100 attempts to prevent storage bloat\r\n  if (attempts.length > 100) {\r\n    attempts.splice(0, attempts.length - 100);\r\n  }\r\n  \r\n  localStorage.setItem(LOGIN_ATTEMPTS_KEY, JSON.stringify(attempts));\r\n}\r\n\r\n// Verify admin password\r\nexport async function verifyPassword(password: string): Promise<boolean> {\r\n  return bcrypt.compare(password, ADMIN_PASSWORD_HASH);\r\n}\r\n\r\n// Login admin\r\nexport async function loginAdmin(password: string): Promise<{ success: boolean; error?: string }> {\r\n  if (typeof window === 'undefined') {\r\n    return { success: false, error: 'Server-side rendering not supported' };\r\n  }\r\n  \r\n  // Check if account is locked\r\n  if (isAccountLocked()) {\r\n    const minutes = getLockoutTimeRemaining();\r\n    saveLoginAttempt(false);\r\n    return { success: false, error: `Account locked. Try again in ${minutes} minutes.` };\r\n  }\r\n  \r\n  // Verify password\r\n  const isValid = await verifyPassword(password);\r\n  \r\n  if (!isValid) {\r\n    saveLoginAttempt(false);\r\n    const attempts = getLoginAttempts();\r\n    const ip = getClientIp();\r\n    const cutoffTime = Date.now() - LOCKOUT_DURATION;\r\n    const recentFailures = attempts.filter(\r\n      a => a.ipAddress === ip && !a.successful && new Date(a.timestamp).getTime() > cutoffTime\r\n    );\r\n    const remainingAttempts = MAX_FAILED_ATTEMPTS - recentFailures.length;\r\n    \r\n    if (remainingAttempts <= 0) {\r\n      return { success: false, error: 'Account locked for 30 minutes due to too many failed attempts.' };\r\n    }\r\n    \r\n    return { success: false, error: `Invalid password. ${remainingAttempts} attempts remaining.` };\r\n  }\r\n  \r\n  // Create session\r\n  const session: AdminSession = {\r\n    isAuthenticated: true,\r\n    loggedInAt: new Date().toISOString(),\r\n    lastActivity: new Date().toISOString(),\r\n    ipAddress: getClientIp(),\r\n    sessionToken: generateSessionToken(),\r\n  };\r\n  \r\n  localStorage.setItem(SESSION_KEY, JSON.stringify(session));\r\n  saveLoginAttempt(true);\r\n  \r\n  // Log the login action\r\n  logAdminAction('LOGIN', { ipAddress: session.ipAddress });\r\n  \r\n  return { success: true };\r\n}\r\n\r\n// Get current session\r\nexport function getSession(): AdminSession | null {\r\n  if (typeof window === 'undefined') return null;\r\n  \r\n  const stored = localStorage.getItem(SESSION_KEY);\r\n  if (!stored) return null;\r\n  \r\n  const session: AdminSession = JSON.parse(stored);\r\n  \r\n  // Check if session has expired\r\n  const lastActivity = new Date(session.lastActivity).getTime();\r\n  if (Date.now() - lastActivity > SESSION_TIMEOUT) {\r\n    logoutAdmin();\r\n    return null;\r\n  }\r\n  \r\n  return session;\r\n}\r\n\r\n// Check if admin is authenticated\r\nexport function isAuthenticated(): boolean {\r\n  const session = getSession();\r\n  return session?.isAuthenticated === true;\r\n}\r\n\r\n// Update last activity\r\nexport function updateActivity(): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  const session = getSession();\r\n  if (session) {\r\n    session.lastActivity = new Date().toISOString();\r\n    localStorage.setItem(SESSION_KEY, JSON.stringify(session));\r\n  }\r\n}\r\n\r\n// Logout admin\r\nexport function logoutAdmin(): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  // Get session directly from storage to avoid infinite loop with getSession()\r\n  const stored = localStorage.getItem(SESSION_KEY);\r\n  if (stored) {\r\n    try {\r\n      const session: AdminSession = JSON.parse(stored);\r\n      logAdminAction('LOGOUT', { sessionToken: session.sessionToken });\r\n    } catch {\r\n      // Ignore parsing errors\r\n    }\r\n  }\r\n  \r\n  localStorage.removeItem(SESSION_KEY);\r\n}\r\n\r\n// Log admin action\r\nexport function logAdminAction(action: string, details: Record<string, unknown>): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  const actions = getAdminActions();\r\n  const session = getSession();\r\n  \r\n  const newAction: AdminAction = {\r\n    id: `action-${Date.now()}`,\r\n    action,\r\n    details: {\r\n      ...details,\r\n      userAgent: typeof window !== 'undefined' ? window.navigator.userAgent : 'unknown',\r\n    },\r\n    timestamp: new Date().toISOString(),\r\n    ipAddress: session?.ipAddress || getClientIp(),\r\n    sessionToken: session?.sessionToken || 'anonymous',\r\n  };\r\n  \r\n  actions.push(newAction);\r\n  \r\n  // Keep only last 500 actions to prevent storage bloat\r\n  if (actions.length > 500) {\r\n    actions.splice(0, actions.length - 500);\r\n  }\r\n  \r\n  localStorage.setItem(ADMIN_ACTIONS_KEY, JSON.stringify(actions));\r\n}\r\n\r\n// Get admin actions\r\nexport function getAdminActions(): AdminAction[] {\r\n  if (typeof window === 'undefined') return [];\r\n  const stored = localStorage.getItem(ADMIN_ACTIONS_KEY);\r\n  return stored ? JSON.parse(stored) : [];\r\n}\r\n\r\n// Get login attempts for display\r\nexport function getLoginAttemptsForDisplay(): LoginAttempt[] {\r\n  return getLoginAttempts().slice(-20).reverse(); // Last 20, most recent first\r\n}\r\n\r\n// Audit log storage key\r\nconst AUDIT_LOG_KEY = 'stylash_audit_log';\r\n\r\n// Get audit log entries\r\nexport function getAuditLog(): import('./types').AuditLogEntry[] {\r\n  if (typeof window === 'undefined') return [];\r\n  const stored = localStorage.getItem(AUDIT_LOG_KEY);\r\n  return stored ? JSON.parse(stored) : [];\r\n}\r\n\r\n// Add audit log entry\r\nexport function addAuditLogEntry(entry: Omit<import('./types').AuditLogEntry, 'id'>): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  const logs = getAuditLog();\r\n  const newEntry: import('./types').AuditLogEntry = {\r\n    ...entry,\r\n    id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n  };\r\n  \r\n  logs.push(newEntry);\r\n  \r\n  // Keep only last 1000 entries\r\n  if (logs.length > 1000) {\r\n    logs.splice(0, logs.length - 1000);\r\n  }\r\n  \r\n  localStorage.setItem(AUDIT_LOG_KEY, JSON.stringify(logs));\r\n}\r\n\r\n// Get login activity for security panel\r\nexport function getLoginActivity(): import('./types').LoginAttempt[] {\r\n  return getLoginAttempts();\r\n}\r\n\r\n// Get active sessions (simplified - in real app would track multiple devices)\r\nexport function getActiveSessions(): { token: string; ip: string; startedAt: string }[] {\r\n  if (typeof window === 'undefined') return [];\r\n  \r\n  const stored = localStorage.getItem(SESSION_KEY);\r\n  if (!stored) return [];\r\n  \r\n  try {\r\n    const session: import('./types').AdminSession = JSON.parse(stored);\r\n    return [{\r\n      token: session.sessionToken,\r\n      ip: session.ipAddress,\r\n      startedAt: session.loggedInAt,\r\n    }];\r\n  } catch {\r\n    return [];\r\n  }\r\n}\r\n\r\n// Force logout a session\r\nexport function forceLogoutSession(token: string): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  const stored = localStorage.getItem(SESSION_KEY);\r\n  if (stored) {\r\n    try {\r\n      const session: import('./types').AdminSession = JSON.parse(stored);\r\n      if (session.sessionToken === token) {\r\n        logoutAdmin();\r\n      }\r\n    } catch {\r\n      // Ignore parsing errors\r\n    }\r\n  }\r\n}\r\n\r\n// Clear all auth data (for testing)\r\nexport function clearAllAuthData(): void {\r\n  if (typeof window === 'undefined') return;\r\n  localStorage.removeItem(SESSION_KEY);\r\n  localStorage.removeItem(LOGIN_ATTEMPTS_KEY);\r\n  localStorage.removeItem(ADMIN_ACTIONS_KEY);\r\n  localStorage.removeItem(AUDIT_LOG_KEY);\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAGA,6DAA6D;AAC7D,yBAAyB;AACzB,MAAM,sBAAsB;AAE5B,8CAA8C;AAC9C,MAAM,kBAAkB,KAAK,KAAK;AAElC,mBAAmB;AACnB,MAAM,sBAAsB;AAC5B,MAAM,mBAAmB,KAAK,KAAK,MAAM,aAAa;AAEtD,eAAe;AACf,MAAM,cAAc;AACpB,MAAM,qBAAqB;AAC3B,MAAM,oBAAoB;AAE1B,8EAA8E;AAC9E,SAAS;IACP,wCAAmC,OAAO;;;IAC1C,oEAAoE;IACpE,sEAAsE;IACtE,IAAI;AAON;AAEA,yBAAyB;AACzB,SAAS;IACP,OAAO,CAAC,QAAQ,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG,KAAK;AAC5E;AAGO,SAAS;IACd,wCAAmC,OAAO;;;IAE1C,MAAM;IACN,MAAM;IACN,MAAM;IAIN,4CAA4C;IAC5C,MAAM;IACN,MAAM;AAWR;AAGO,SAAS;IACd,wCAAmC,OAAO;;;IAE1C,MAAM;IACN,MAAM;IACN,MAAM;IAIN,MAAM;IACN,MAAM;AAYR;AAEA,kCAAkC;AAClC,SAAS;IACP,wCAAmC,OAAO,EAAE;;;IAC5C,MAAM;AAER;AAEA,qBAAqB;AACrB,SAAS,iBAAiB,UAAmB;IAC3C,wCAAmC;;;IAEnC,MAAM;IACN,MAAM;IAEN,oCAAoC;IACpC,MAAM;IACN,MAAM;IAIN,MAAM;AAgBR;AAGO,eAAe,eAAe,QAAgB;IACnD,OAAO,4IAAM,CAAC,OAAO,CAAC,UAAU;AAClC;AAGO,eAAe,WAAW,QAAgB;IAC/C,wCAAmC;QACjC,OAAO;YAAE,SAAS;YAAO,OAAO;QAAsC;IACxE;;;IASA,kBAAkB;IAClB,MAAM;IAmBN,iBAAiB;IACjB,MAAM;AAeR;AAGO,SAAS;IACd,wCAAmC,OAAO;;;IAE1C,MAAM;IAGN,MAAM;IAEN,+BAA+B;IAC/B,MAAM;AAOR;AAGO,SAAS;IACd,MAAM,UAAU;IAChB,OAAO,SAAS,oBAAoB;AACtC;AAGO,SAAS;IACd,wCAAmC;;;IAEnC,MAAM;AAKR;AAGO,SAAS;IACd,wCAAmC;;;IAEnC,6EAA6E;IAC7E,MAAM;AAWR;AAGO,SAAS,eAAe,MAAc,EAAE,OAAgC;IAC7E,wCAAmC;;;IAEnC,MAAM;IACN,MAAM;IAEN,MAAM;AAoBR;AAGO,SAAS;IACd,wCAAmC,OAAO,EAAE;;;IAC5C,MAAM;AAER;AAGO,SAAS;IACd,OAAO,mBAAmB,KAAK,CAAC,CAAC,IAAI,OAAO,IAAI,6BAA6B;AAC/E;AAEA,wBAAwB;AACxB,MAAM,gBAAgB;AAGf,SAAS;IACd,wCAAmC,OAAO,EAAE;;;IAC5C,MAAM;AAER;AAGO,SAAS,iBAAiB,KAAkD;IACjF,wCAAmC;;;IAEnC,MAAM;IACN,MAAM;AAaR;AAGO,SAAS;IACd,OAAO;AACT;AAGO,SAAS;IACd,wCAAmC,OAAO,EAAE;;;IAE5C,MAAM;AAaR;AAGO,SAAS,mBAAmB,KAAa;IAC9C,wCAAmC;;;IAEnC,MAAM;AAWR;AAGO,SAAS;IACd,wCAAmC;;;AAKrC"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Marco/OneDrive/Desktop/test/stylash/app/admin/layout.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { useEffect } from \"react\";\r\nimport { useRouter, usePathname } from \"next/navigation\";\r\nimport { isAuthenticated, updateActivity } from \"@/lib/auth\";\r\n\r\nexport default function AdminLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode;\r\n}) {\r\n  const router = useRouter();\r\n  const pathname = usePathname();\r\n\r\n  useEffect(() => {\r\n    if (pathname === \"/admin/login\") return;\r\n    if (!isAuthenticated()) {\r\n      router.push(\"/admin/login\");\r\n      return;\r\n    }\r\n    updateActivity();\r\n  }, [router, pathname]);\r\n\r\n  return <>{children}</>;\r\n}"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAJA;;;;;AAMe,SAAS,YAAY,EAClC,QAAQ,EAGT;IACC,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,WAAW,IAAA,iJAAW;IAE5B,IAAA,kNAAS,EAAC;QACR,IAAI,aAAa,gBAAgB;QACjC,IAAI,CAAC,IAAA,8HAAe,KAAI;YACtB,OAAO,IAAI,CAAC;YACZ;QACF;QACA,IAAA,6HAAc;IAChB,GAAG;QAAC;QAAQ;KAAS;IAErB,qBAAO;kBAAG;;AACZ"}}]
}